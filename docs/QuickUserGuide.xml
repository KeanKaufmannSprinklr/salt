<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.oasis-open.org/docbook/xml/5.0/rng/docbookxi.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <info>
        <title>Salt - Quick User Guide</title>
        <author>
            <orgname>saltNpepper</orgname>
            <email>user@example.com</email>
        </author>
    </info>
    <preface>
        <title>Introduction</title>
        <para> This article gives a brief overview over the linguistic meta model Salt and explains
            how to use and how to work with it's model elements. We only describe the use of the
            meta model SaltCommon here, which is one of three meta models coming with the Salt
            project. For giving a short but concise feeling of what Salt is made for, we give an
            example in Java Code, followed by explanations. The description exemplifies the creation
            of a new corpus, starting from modeling it's structure, the primary data, the
            tokenization, adding annotations and higher structures like hierarchies and so on. At
            the end of this article, we show how such a corpus model can be stored into SaltXML and
            loaded into main memory again. We also provide a sample project which creates and
            persists the sample described here. You can download that sample project via our svn
            from: download sample project from SVN: <link
                xlink:href="https://korpling.german.hu-berlin.de/svn/saltnpepper/salt/tags/salt-1.1.3/salt-saltSample"
                >https://korpling.german.hu-berlin.de/svn/saltnpepper/salt/tags/salt-1.1.3/salt-saltSample</link>
            Salt is a graph meta based model, and therefore each model element in Salt is either a
            node, an edge (relation), a graph, a label or a layer. This means nodes can be connected
            via relations. Nodes and relations are contained in a graph. They also can be contained
            in layers, which define kinds of sub-graphs. A layer itself is also contained in a
            graph. Each element can be labeled, and even a label can be labeled by another label. </para>

    </preface>
    <toc/>
    <chapter xml:id="chSample">
        <title>The Sample</title>
        <para> In this article, we present only a very simple example to show the main components of
            Salt in a very brief way. The example is just used to clarify the mechanisms of Salt and
            therefore does not claim to advocate to a specific linguistic school. In general, Salt
            is able to contain very complex corpus structures (which means the inner organization of
            a corpus), having a recursive sub-corpus - super-corpus structure with a lot of primary
            data. For simplifying the example, we decided to use a single corpus object (which is
            also the root corpus) containing one document. The document contains the primary text
            "Is this example more complicated than it appears to be?". After showing how to create a
            corpus structure in section corpus structure, we show a tokenization of the primary text
            by adding one token for each word of that sentence in tokenization. We illustrate how to
            annotate these words with part-of-speech and lemma annotations. In higher hierarchies,
            we show the modeling of higher hierarchies having a part-of relationship in Salt, we
            decided to model a syntax analysis above the given sentence. In Salt, there also exists
            a second way of creating aggregations of tokens called 'spans'. The semantics of spans
            is slightly different compared to that of hierarchies. In contrast to hierarchies, spans
            aggregate tokens to a set to be annotated once. You might, for instance, not want to
            annotate a single token only, but a whole structure containing a set of possibly
            discontinuous tokens. The use of spans is shown in spans and demonstrated with the use
            case of an information structure analysis. The last type of model elements we show here
            is a loose relation or edge between tokens and/or other structures called pointing
            relation. To show the use of pointing relations in <link xlink:href="#chPointingRelation">pointing relations</link>, we use an
            anaphoric annotation to connect the word "it" with the words "This sample". After having
            illustrated the modeling of a corpus with Salt in <link xlink:href="#chPersistLoad">persist and load</link> we show
            how to persist and load a model to disk. </para>
    </chapter>
    <chapter xml:id="chCorpusStructure">
        <title>Corpus Structure</title>
        <para> Due to it´s graph based structure, even sub- and super-corpora are modeled as nodes
            having relations connecting them and creating a containment relationship. The only
            element not following the graph approach is the element SaltProject. This element serves
            as container for a set of corpus structures represented via the model element
                <classname>SCorpusGraph</classname>. Such a corpus structure is organized as a graph
            and contains corpora and documents. Salt distinguishes between a corpus (which can
            contain other corpora and documents) and documents (which only contain the document
            structure). The document structure itself is organized as a graph called
                <classname>SDocumentGraph</classname>. The <classname>SDocumentGraph</classname> is
            the element containing the primary data and the linguistic analysis. The corpus
            structure is just for organizing a complex linguistic project. A corpus in Salt is
            represented by the element <classname>SCorpus</classname> and a document is represented
            by the element <classname>SDocument</classname>. In this section, we create a simple
            corpus structure having one corpus and one document. Since corpora and documents are
            nodes, they can be labeled. To show this mechanism, we create a meta-annotation,
            defining the annotator of that corpus. A meta-annotation is represented via the element
                <classname>SMetaAnnotation</classname>. The corpus structure created here is shown
            in the figure. The following snippet shows the creation of the container object
            SaltProject, which shall contain our corpus model:
            <programlisting language="Java">
        SaltProject saltProject= SaltFactory.eINSTANCE.createSaltProject();
        </programlisting>
            The next snippet illustrates the creation of the corpus structure by creating a corpus
            graph, a corpus named 'sampleCorpus' and a document named 'sampleDocument'. Afterwards,
            the creation of the corpus is shown, followed by a meta annotation declaring it´s
            annotator.
            <programlisting language="Java">SCorpusGraph sCorpGraph= SaltFactory.eINSTANCE.createSCorpusGraph();
saltProject.getSCorpusGraphs().add(sCorpGraph);
SCorpus sampleCorpus= SaltFactory.eINSTANCE.createSCorpus();
sampleCorpus.setSName("sampleCorpus");
sCorpGraph.addSNode(sampleCorpus);
//creates a meta annotation on the corpus sampleCorpus
sampleCorpus.createMetaAnnotation(null, "annotator", "A. Nyone");</programlisting>
            The meta annotation is created via the method
                <methodname>createMetaAnnotation()</methodname>. This method takes three arguments:
            a namespace which is optional and can be used to take further information, the name of
            the annotation and the value of the annotation. We now create the document that will
            later contain a primary data text and all of it's annotations.
            <programlisting language="Java">SDocument sampleDocument= SaltFactory.eINSTANCE.createSDocument();
sampleDocument.setSName("sampleDocument");
//adds the document to the graph and automatically creates an relations between the corpus and the document
sCorpGraph.addSDocument(sampleCorpus, sampleDocument);        </programlisting>
            In the given snippets, we have not shown the creation of relations between the corpus
            and the document node. The creation of the relation between them, which is of the type
                <classname>SCorpusDocumentRelation</classname>, is hidden behind the method
                <methodname>addSDocument(sampleCorpus, sampleDocument)</methodname> and will be
            created automatically (although it might also be created explicitly). The following
            snippet will show the same code with explicit creation of the relation.
            <programlisting language="Java">SDocument sampleDocument= SaltFactory.eINSTANCE.createSDocument();
sampleDocument.setSName("sampleDocument");
//adding document to the graph
sCorpGraph.addSNode(sampleDocument);
//creating relation (edge)
SCorpusDocumentRelation sRelation= SaltFactory.eINSTANCE.createSCorpusDocumentRelation();
//adding source (the corpus) to relation
sRelation.setSCorpus(sampleCorpus);
//adding target (the document) to relation
sRelation.setSDocument(sampleDocument);
//adding the relation to the graph
sCorpGraph.addSRelation(sRelation);        </programlisting>
            We also did not show the id mechanism in Salt. Such an identifier is organized like an
                <classname>URI</classname> and follows the scheme 'salt'. A description can be found
            here. Now we leave the corpus graph and step into the document graph by modeling a
            primary text in primary data. </para>
    </chapter>
    <chapter xml:id="chDocumentStructure">
        <title>Document Structure</title>
        <para>Now we are leaving the corpus-structure and going to the document-structure. The
            difference between both is that the corpus-structure groups corpora and documents to
            super and sub corpora and documents and the document-structure contains primary data and
            their annotations. Therefore we need to add a <classname>SDocumentGraph</classname>
            object to the <classname>SDocument</classname>, whicch acts as container for the primary
            data and linguistic annotationns.
            <programlisting language="Java">sampleDocument.setSDocumentGraph(SaltFactory.eInstance.createSDocumentGraph);</programlisting>
        </para>
    </chapter>
    <chapter xml:id="chPrimaryData">
        <title>Primary Data</title>
        <para> As already mentioned, now we go over to model a document structure, using the
                <classname>SDocumentGraph</classname> element. When creating a
                <classname>SDocument</classname> object, a <classname>SDocumentGraph</classname>
            object will be generated automatically. At this stage, we will start to fill in the
            document structure with content. We show how to add the primary text "Is this example
            more complicated than it appears to?" to the document graph. Primary data is generally
            represented by the abstract element <classname>SSequentialDS</classname>, a primary text
            is represented by the derived element <classname>STextualDS</classname>.
            <programlisting language="Java">STextualDS primaryText = SaltFactory.eINSTANCE.createSTextualDS();
//setting the primary text to the sentence "Is this example more complicated than it appears to be?" 
primaryText.setSText("Is this example more complicated than it appears to?");
//adding the text to the document-graph
sampleDocument.getSDocumentGraph().addSNode(sTextualDS);</programlisting>
            For creating a primary text node, Salt offers the following shortcut:
            <programlisting language="Java">STextualDS primaryText = sampleDocument.getSDocumentGraph().createSTextualDS("Is this example more complicated than it appears to?");</programlisting>
        </para>
    </chapter>
    <chapter xml:id="chTokenization">
        <title>Tokenization</title>
        <para> A token in Salt is not bound to a linguistic unit - in this example we show how to
            tokenize words, although tokenizations by characters, syllables or sentences and so on
            are possible, too. For tokenizing a primary text, we need the character offset of the
            start and the end position for each token in the text. The word "Is" in the sample text,
            for instance, has the start position 0 and the end position 1. <note>
                <para>Note that the positions are counted between two characters.</para>
            </note>
            <table>
                <caption/>
                <tr>
                    <td/>
                    <td>Is</td>
                    <td/>
                    <td>SPACE</td>
                    <td/>
                    <td>this</td>
                    <td/>
                    <td>SPACE</td>
                    <td/>
                    <td>example</td>
                    <td/>
                    <td>SPACE</td>
                    <td/>
                    <td>more</td>
                    <td/>
                    <td>SPACE</td>
                    <td/>
                    <td>complicated</td>
                    <td/>
                    <td>SPACE</td>
                    <td/>
                    <td>than</td>
                    <td/>
                    <td>SPACE</td>
                    <td/>
                    <td>it</td>
                    <td/>
                    <td>SPACE</td>
                    <td/>
                    <td>appears</td>
                    <td/>
                    <td>SPACE</td>
                    <td/>
                    <td>to</td>
                    <td/>
                    <td>SPACE</td>
                    <td/>
                    <td>be</td>
                    <td/>
                    <td>SPACE</td>
                    <td/>
                    <td>?</td>
                    <td/>
                </tr>
                <tr>
                    <td>0</td>
                    <td/>
                    <td>1</td>
                    <td/>
                    <td>2</td>
                    <td/>
                    <td>3</td>
                    <td/>
                    <td>7</td>
                    <td/>
                    <td>8</td>
                    <td/>
                    <td>15</td>
                    <td/>
                    <td>16</td>
                    <td/>
                    <td>20</td>
                    <td/>
                    <td>21</td>
                    <td/>
                    <td>32</td>
                    <td/>
                    <td>33</td>
                    <td/>
                    <td>37</td>
                    <td/>
                    <td>38</td>
                    <td/>
                    <td>40</td>
                    <td/>
                    <td>41</td>
                    <td/>
                    <td>48</td>
                    <td/>
                    <td>49</td>
                    <td/>
                    <td>51</td>
                    <td/>
                    <td>52</td>
                    <td/>
                    <td>54</td>
                    <td/>
                    <td>55</td>
                </tr>
            </table> In the given table SPACE is an alias for a space or a blank ' '. The following
            figure shows an excerpt of the document graph we want to model in Salt. The figure only
            shows the tokens overlapping the words 'Is', 'this', 'example' and '.'. In the following
            snippet we show an example of creating a tokenization by creating just one token. The
            creation of all other tokens is done in the same manner. Each token will be added to the
            morphology layer. A layer in Salt is represented by the element
                <classname>SLayer</classname> and defines a kind of a sub-graph, for instance for
            clustering nodes to a specific linguistic analysis. The snippet also shows the
            annotation of tokens with part-of-speech and lemma annotations using the element
                <classname>SAnnotation</classname>.
            <programlisting language="Java">//creating a layer named morphology
SLayer morphLayer = SaltFactory.eINSTANCE.createSLayer();
morphLayer.setSName("morphology");
sampleDocument.getSDocumentGraph().addSLayer(morphLayer);
    
//creating tokenization for the token 'Is' 
SToken tok_is= sampleDocument.getSDocumentGraph().createSToken(primaryText, 0, 2);
//adding the new token to the morphology layer
morphLayer.getSNodes().add(tok_is);
//adding a part-of-speech annotation to the new token
tok_is.createSAnnotation(null, "pos", "VBZ");
//adding a lemma annotation to the new token
tok_is.createSAnnotation(null, "lemma", "be");
    
//...</programlisting>
            Again, we did not explicitly create the relations: their creation is hidden in the
            method <methodname>createSToken()</methodname>. But in the background Salt creates a
            node of type <classname>SToken</classname> for the token and a relation called
                <classname>STextualRelation</classname> which connects the token and the primary
            data node. Since Salt does not know any further elements other than the graph elements
            mentioned, the character positions, to which the tokens refer to are stored as labels of
            the edges. For such a kind of label we use a special type named
                <classname>SFeature</classname>. When just working with Salt and not creating an own
            derived meta model, the mechanism is not important. It is just important, that the
            positions can be set and get via the methods
                <methodname>STextualRelation.getSStart()</methodname> or
                <methodname>STextualRelation.setSStart(value)</methodname>. The same goes for the
            end position <varname>SEnd</varname>. </para>
    </chapter>
    <chapter xml:id="chHierarchie">
        <title>Hierarchies</title>
        <para> In Salt, you can create higher structures representing hierarchies for instance to
            model syntactic annotations like constituencies. These hierarchies are realized via the
            nodes <classname>SStructure</classname> and can be connected to each other via edges of
            type <classname>SDominanceRelation</classname>. A relation of that type has the
            semantics of a part-of relation, which means that the target of that relation is a part
            of the source of that relation. In this example, we want to create a syntactic analysis
            as part of a syntactic layer. The following figure shows the structure we will create in
            this step of the example. The following snippet gives an impression of how to create a
            hierarchy like the one shown in the picture in Salt.
            <programlisting language="Java">//creating a list of nodes, which shall be overlapping by NP-node
EList&lt;SStructuredNode&gt; overlappingNodes= new BasicEList&lt;SStructuredNode&gt;();
overlappingNodes.add(tok_this);
overlappingNodes.add(tok_example);
//adding NP-Node to graph and automatically creating edges to overlapping nodes
SStructure np_1= sampleDocument.getSDocumentGraph().createSStructure(overlappingNodes);
np_1.createSAnnotation(null, "cat", "NP");
            
//...
            
overlappingNodes= new BasicEList&lt;SStructuredNode&gt;();
overlappingNodes.add(tok_is);
overlappingNodes.add(np_1);
overlappingNodes.add(tok_is);
overlappingNodes.add(tok_is);
SStructure sq= sampleDocument.getSDocumentGraph().createSStructure(overlappingNodes);
np_1.createSAnnotation(null, "cat", "SQ");
            
//creating a syntax layer
SLayer syntaxLayer = SaltFactory.eINSTANCE.createSLayer();
syntaxLayer.setSName("syntax");
docGraph.addSLayer(syntaxLayer);
            
//adding syntactic nodes to syntax layer
syntaxLayer.getNodes().add(np_1);
syntaxLayer.getNodes().add(sq);        </programlisting>
        </para>
    </chapter>
    <chapter xml:id="chSpan">
        <title>Spans</title>
        <para> If a whole (possibly discontinuous) set of nodes has to be annotated with the very
            same annotation, a span can be used to aggregate the nodes. Instead of an annotation for
            each node, a single annotation for the span can be created then. This annotation belongs
            to the set of nodes (the span), but not to any of the single nodes. In our example we
            show the use of spans building an information structure analysis. Spans in Salt are
            realized by nodes of the type <classname>SSpan</classname>, they can be connected to
                <classname>SToken</classname> nodes via edges of type
                <classname>SSpanningRelation</classname>. The following figure shows the information
            structure analysis to be modeled. The following snippet shows the code used to create
            the analysis shown in the figure.
            <programlisting language="Java">//create span overlaping only one token
SSpan contrast_focus= docGraph.createSSpan(tok_is);
contrast_focus.createSAnnotation(null, "inf-struct", "contrast-focus");
                    
//create a list of tokens taking part in the set to be annotated as a bundle
EList&lt;SToken&gt; overlappingTokens= new BasicEList&lt;SToken&gt;();
overlappingTokens.add(tok_this);
overlappingTokens.add(tok_example);
overlappingTokens.add(tok_more);
overlappingTokens.add(tok_complicated);
overlappingTokens.add(tok_than);
overlappingTokens.add(tok_it);
overlappingTokens.add(tok_appears);
overlappingTokens.add(tok_to);
overlappingTokens.add(tok_be);
overlappingTokens.add(tok_PUNC);
                    
//create span overlaping a set of tokens    
SSpan topic= docGraph.createSSpan(overlappingTokens);
topic.createSAnnotation(null, "inf-struct", "topic");                </programlisting>
        </para>
    </chapter>
    <chapter xml:id="chPointingRelation">
        <title>Pointing Relations</title>
        <para> Until now, we have shown the creation of structures using nodes. Although we always
            connected nodes via edges, we haven't explicitly shown how to model these edges. The use
            of edges for creating tokens, spans and hierarchies was hidden behind the methods we
            used. In Salt, it is also possible to explicitly create edges and use them to connect
            two nodes. Edges can be annotated in the same way nodes can be. Now we will show another
            type of edge, which renders a more loose relation between nodes. In contrast to
                <classname>SSpanningRelations</classname> and
                <classname>SDominanceRelations</classname>, which can only connect specific kinds of
            nodes, the type <classname>SPointingRelation</classname> can connect
                <classname>SToken</classname>, <classname>SSpan</classname> and
                <classname>SStructure</classname> nodes with each other and vice versa. These edges
            for instance can be used to model anaphoric relations between words, phrases, sentences
            and so on. Edges in general can be typed with a linguistic meaning by setting their
            attribute <varname>SType</varname>. Here we want to illustrate the use of
                <classname>SPointingRelations</classname> and their <varname>SType</varname>
            attribute by an example, connecting the token covering the word "it" to the set "the
            example". To bundle the words "the example", we first have to create a span covering
            both tokens "the" and "example" following the same mechanism as in the section spans.
            The following snippet shows the creation of the model shown in the figure.
            <programlisting language="Java">//create a span covering the words "the" and "example" 
EList&lt;SToken&gt; overlappingTokens= new BasicEList&lt;SToken&gt;();
overlappingTokens.add(tok_this);
overlappingTokens.add(tok_example);
SSpan span= docGraph.createSSpan(overlappingTokens);
                    
//creating a pointing relations
SPointingRelation sPointingRelation= SaltFactory.eINSTANCE.createSPointingRelation();
//setting token "it" as source of this relation
sPointingRelation.setSStructuredSource(tok_it);
//setting span "this example" as target of this relation
sPointingRelation.setSStructuredTarget(span);
//adding the created relation to the document-graph
sampleDocument.getSDocumentGraph().addSRelation(sPointingRelation);
//adding the type to the relation
sPointingRelation.addSType("anaphoric");</programlisting>
        </para>
    </chapter>
    <chapter xml:id="chIdentifiers">
        <title>Identifiers in Salt</title>
        <para> In the background each element in Salt gets a unique identifier called
                <classname>SElementId</classname>. Such an identifier is organized like an URI. The
            inner structure of a URI is shown here:
            <programlisting>[scheme:][//authority][path][?query][#fragment]                    </programlisting>
            The scheme of these identifiers is 'salt', in the current version, the Salt ids also
            does not support an authority or a query. The path is organized following the tree
            structure of the corpus structure, starting with the name (<varname>SName</varname>
            value) of the root corpus, via an unbound number of sub corpora and ends with the
            document. The identifier for each element is computed automatically by extending the
            identifier of its parent element. For instance the identifier of a sub corpus named
            'corp2' is computed by extending the identifier of its parent corpus 'corp1'. For
            instance the identifier for a document named 'doc1', being contained in a corpus named
            'corp2', being contained in a corpus named 'corp1' (which is the root) would look like
            this: <programlisting>salt:/corp1/corp2/doc1</programlisting> The same mechanism of
            creating identifiers of the corpus structure is used for for elements of the document
            structure. But the name of these elements is given in the fragment part. Since the
            content of the document structure is not necessarily a tree-like structure, it is not
            possible to have a unique path from an element to its root. For instance a token named
            'tok1' added to the document having the identifier 'salt/corp1/corp2/doc1' receives the
            identifier: <programlisting>salt:/corp1/corp2/doc1#tok1</programlisting> The same holds
            for relations. These URI's or <classname>SElementId</classname>'s can be used to
            identify and search for elements in the corresponding graphs. </para>
    </chapter>
    <chapter xml:id="chPersistLoad">
        <title>Persist and Load a Model</title>
        <para> Salt provides several methods to persist and load a model. You can either store the
            entire model or parts of it in SaltXML by using methods provided by EMF or you can use
            the methods coming with the <classname>SaltProject</classname> which offer an easier
            possibility for storing and loading models. In this article, we only show the persisting
            and loading of an entire model using the methods provided by the class
                <classname>SaltProject</classname>. Persisting a model is very easy: only a nonempty
                <classname>SaltProject</classname> object and a valid local URI are needed. The
            following snippet shows how to persist a model. <programlisting>saltProject.saveSaltProject(URI);</programlisting>
            <note>
                <para> The URI used as parameter is not a uri of type
                        <classname>java.net.Uri</classname> - it is of type
                        <classname>org.eclipse.emf.common.util.URI</classname>. </para>
            </note> To load a valid SaltXML document, create an empty SaltProject object and call
            the load method as shown in the following snippet.
            <programlisting language="Java">saltProject= SaltFactory.eINSTANCE.createSaltProject();
saltProject.loadSaltProject(URI);                    </programlisting>
        </para>
        <para>Salt provides different methods to persist and load a model in different formats. The
            most native way to store a Salt model is to use its XMI serialization called SaltXML.
            SaltXML is a automatic generated format by the underlying framework EMF. The reesource
            mechanism of EMF makes it very comfortable and fast to load and persist the entire Salt
            model or just parts of it in different formats. But there are still some configurational
            issues, you have to take care of. Therfore the Salt metamodel provides shortcuts to
            store an entire Salt model or just the corpus structure or the document structure by
            just calling one method. We here want to concentrate on these shortcuts, for a more
            detailed description on how to persist and load single model elements via EMF please see
            the more detailed ???User Guide???. Before we start with showing the program code, we
            give a brief introduction into the organisation of the SaltXML format. In SaltXML the
            corpus structure including the Saltproject is persisted in one file having the ending
            .saltproject. Each document structure is persisted in its own file having the ending
            .salt. Next to the .saltproject file, the corpus structure (supercorpus-subcorpus
            relation and the corpus-document relation as well) is represented in the file structure
            on the disk. Each corpus will be represented by its own folder, so the file structure
            mirrors the corpus structure.</para>
        <para>The entire Salt model can be stored via calling the method shown <link
                xlink:href="#pl_persist01">here</link>:
            <programlisting xml:id="pl_persist01">saltProject.saveSaltProject(URI);</programlisting>
            To load a valid SaltXML document, create an empty SaltProject object and call the load
            method as shown in the <link xlink:href="#pl_persist02">following snippet</link>
            <programlisting xml:id="pl_persist02">saltProject= SaltFactory.eINSTANCE.createSaltProject();
saltProject.loadSaltProject(URI);</programlisting>
            Uses these methods will persist or load the entire Salt model including the corpus
            structure and the document structure of the documents.</para>
        <para>Sometimes it becomes necessary to store just a single document structure or just to
            store the corpus structure. This can be useful in the case of you don't want to keep the
            entire model in main memory or want to exchange just single parts of it. Therefore each
                <classname>SDocument</classname> object can persist and load its related
                <classname>SDocumentGraph</classname> object separatly via calling the method shown
                <link xlink:href="#pl_persist0">here</link> to persist.
            <programlisting>sampleDocument.save(URI);</programlisting> and load the document
            structure via calling the method:
            <programlisting>sampleDocument.load(URI);</programlisting> or
            <programlisting>sampleDocument.load();</programlisting> in case of a
                <classname>URI</classname> was earlier set with:
            <programlisting>sampleDocument.setSDocumentGraphLocation(URI)</programlisting></para>
        <para>At last we show how to load just the corpus structure seperatly, therfore just call
            the method: <programlisting>saltProject.loadCorpusStructure(URI)</programlisting>All
            these methods for persisting and loading also be used in a static way via the class
                <classname>SaltFactory</classname>. For more information concerning the class
                <classname>SaltFactory</classname> please see the detailed ???User Guide???. </para>
        <para>For information about the internals of persisting and loading a Salt model or just
            parts of it, please see the detailed ???User Guide???.</para>
    </chapter>
    <chapter xml:id="chAccessing">
        <title>Accessing a Salt model</title>
        <para> To access a Salt model, you can use the methods generated by EMF. For attributes and
            references having the cardinality 1, EMF generates simple getters and setters, i.e.
                <methodname>.getXXX()</methodname> and <methodname>.setXXX()</methodname> methods.
            If attributes do not have a cardinality of one, the corresponding
                <methodname>.getXXX()</methodname> method will return a list accessor. You can
            access or manipulate the entries of such a list with these methods:
                <methodname>.add(Object)</methodname> to add an entry,
                <methodname>.get(Position)</methodname> to get the object placed at 'position' in
            that list, and <methodname>.remove(Object)</methodname>
             to remove an entry. </para>
    </chapter>
    <chapter xml:id="chShortCuts">
        <title>Shortcuts</title>
        <para> For more complicated accesses which to not concern just two objects, it can be a very
            long way to get a requested object. Therefore in Salt we offer some shortcuts to have a
            faster access. For instance for getting the text overlapping by any node, you can write
            the following code:
            <programlisting language="Java">//only search for sequences by traversing relations inheriting text
EList&lt;STYPE_NAME&gt; interestingRelations= new BasicEList&lt;STYPE_NAME&gt;();
interestingRelations.add(STYPE_NAME.STEXT_OVERLAPPING_RELATION);
SDataSourceSequence sequence= sampleDocument.getSDocumentGraph().getOverlappedDSSequences(ANY_NODE, interestingRelations).get(0);
//accessing the text
((STextualDS)sequence.getSSequentialDS()).getSText().substring(sequence.getSStart(), sequence.getSEnd());                    </programlisting>
            Additional shortcuts are provided by the <classname>SDocumentGraph</classname> class. </para>
    </chapter>
    <chapter xml:id="chTraversing">
        <title>Traversing graphs</title>
        <para> When working with Salt, it is often necessary to discover the entire graph, or to
            discover a sub-graph covered by a given node, or to discover a a sub-graph connected by
            specific types of relations. For all of these purposes, we offer the generic possibility
            to traverse a graph object (e.g. a <classname>SCorpusGraph</classname> or a
                <classname>SDocumentGraph</classname> object). A traversal can be done in two
            directions: top-down and bottom-up. When using the top-down method, the traversal will
            follow the relation direction (e.g. a ? b: node a will be visited first, followed by
            node b). When using the bottom-up method, the traversal will follow the inverse of the
            relation direction (e.g. a ? b: node b will be visited before node a). Additionally, you
            can choose the order in which nodes will be traversed. For this, we provide two modes:
            depth-first and breadth-first. In depth-first mode, the sub-graph of node b will be
            traversed, before its siblings will be visited. Imagine a tree-like structure having the
            nodes {a,b,c,d} with paths (a, b, c) and (a,d). In this case, node d will be visited
            after a,b,c have been visited. In breadth-first mode, the order of the traversal is the
            other way around, i.e. the nodes a,b,d will be visited before node c. To define the
            behaviour of a traversal, we provide these types, which are combinations of the
            direction and the order of a traversal: <itemizedlist>
                <listitem>
                    <para>de.hu_berlin.german.korpling.saltnpepper.salt.graph.GRAPH_TRAVERSE_TYPE.TOP_DOWN_DEPTH_FIRST</para>
                </listitem>
                <listitem>
                    <para>de.hu_berlin.german.korpling.saltnpepper.salt.graph.GRAPH_TRAVERSE_TYPE.TOP_DOWN_BREADTH_FIRST</para>
                </listitem>
                <listitem>
                    <para>de.hu_berlin.german.korpling.saltnpepper.salt.graph.GRAPH_TRAVERSE_TYPE.BOTTOM_UP_DEPTH_FIRST</para>
                </listitem>
                <listitem>
                    <para>de.hu_berlin.german.korpling.saltnpepper.salt.graph.GRAPH_TRAVERSE_TYPE.BOTTOM_UP_BREADTH_FIRST</para>
                </listitem>
            </itemizedlist> The traversal mechanism uses a callback, therefore you need a class
            implementing the interface
            de.hu_berlin.german.korpling.saltnpepper.salt.saltCore.SGraphTraverseHandler. This
            interface declares the following three methods, which have to be implemented:
            <programlisting language="Java">public boolean checkConstraint( GRAPH_TRAVERSE_TYPE traversalType, 
                                String traversalId,
                                SRelation sRelation, 
                                SNode currNode, 
                                long order);
                        
public void nodeReached( GRAPH_TRAVERSE_TYPE traversalType, 
                         String traversalId,
                         SNode currNode, 
                         SRelation edge, 
                         SNode fromNode, 
                         long order);
                        
public void nodeLeft( GRAPH_TRAVERSE_TYPE traversalType, 
                      String traversalId,
                      SNode currNode, 
                      SRelation edge, 
                      SNode fromNode, 
                      long order);</programlisting>
            When the traversal engine reaches a new node during the traversal, the method
                <methodname>checkConstraint(...)</methodname> is called. It checks whether the
            following nodes and their sub-graphs should be processed any further. When this method
            returns true, the method <methodname>nodeReached(...)</methodname> is called next.
            Before a node is left, the method <methodname>nodeLeft(...)</methodname> is called. <note>
                <para>The order of the method invocations depends on the traversal type used.</para>
            </note> The following example shows the order of calls for the sample graph given in the
            following figure. sample graph for traversal Here, we list the callbacks in correct
            order in case of a depth-first traversal. We assume that the called object returns true
            for the method <methodname>checkConstraint(...)</methodname> on all nodes except node
            span1. In the case of node span1, the checkConstraint(...) method returns false.
            Therefore, no <methodname>nodeReached(...)</methodname> and
                <methodname>nodeLeft(...)</methodname> method will be called for this node. Note,
            that the list of parameters of the functions presented here is bigger than shown, e.g.
            the traversing policy and the edge via which the node has been reached is given, too.
            <orderedlist>
                <listitem><para>checkConstraint(struct1)</para></listitem>
                <listitem><para>nodeReached(struct1)</para></listitem>
                <listitem><para>checkConstraint(struct2)</para></listitem>
                <listitem><para>nodeReached(struct2)</para></listitem>
                <listitem><para>checkConstraint(tok1)</para></listitem>
                <listitem><para>nodeReached(tok1)</para></listitem>
                <listitem><para>nodeLeft(tok1)</para></listitem>
                <listitem><para>checkConstraint(span1)</para></listitem>
                <listitem><para>nodeLeft(struct2)</para></listitem>
                <listitem><para>nodeLeft(struct1)</para></listitem>
            </orderedlist>
            To start the traversal, use the following method, available in any object derived from
                <classname>SGraph </classname>(e.g. <classname>SCorpusGraph</classname> or
                <classname>SDocumentGraph</classname>):
            <programlisting language="Java">void traverse( EList&lt;? extends SNode&gt; startSNodes, 
               GRAPH_TRAVERSE_TYPE traverseType, 
               String traverseId, 
               SGraphTraverseHandler traverseHandler);                            </programlisting>
            or <programlisting language="Java">void traverse( EList&lt;? extends SNode&gt; startSNodes, 
               GRAPH_TRAVERSE_TYPE traverseType, 
               String traverseId, 
               SGraphTraverseHandler traverseHandler, 
               boolean isCycleSafe);</programlisting>
            <parameter>startSNodes</parameter> represents a list of nodes, which shall be the entry
            point for traversal, <parameter>traverseType</parameter> is the combination of traversal
            direction and order explained above, traverseid is an identifier which can be used to
            identify the specific traversal job (this can be helpful if more than one is running at
            the same time) and traverseHandler, is the object which will be used for callback.
            Additionally, you can set a flag to protect the traversal engine from running in cycles.
            Per default, this flag is set to false and your traverseHandler has to deal with cyclic
            graphs itself. </para>
    </chapter>
</book>
