<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0">
    <info>
        <title>Salt</title>
        <subtitle>Model Guide</subtitle>
        <authorgroup>
            <author>
                <personname>
                    <firstname>Florian</firstname>
                    <surname>Zipser</surname>
                </personname>
                <email>saltnpepper@lists.hu-berlin.de</email>
            </author>
            <author>
                <orgname xml:id="org1">INRIA</orgname>
            </author>
            <author>
                <orgname xml:id="org2">SFB 632 Information Structure / D1 Linguistic
                    Database</orgname>
            </author>
            <author>
                <orgname xml:id="org3">Humboldt-Universität zu Berlin</orgname>
            </author>
            <author>
                <orgname xml:id="org4">Universität Potsdam</orgname>
            </author>
        </authorgroup>
        <copyright>
            <year>2012</year>
            <holder><xref linkend="org1"/>, <xref linkend="org2"/>, <xref linkend="org3"/>, <xref
                    linkend="org1"/>,<xref linkend="org4"/>, All rights reserved.</holder>
        </copyright>
        <releaseinfo>Version ${project.version}</releaseinfo>
    </info>
    <!-- 
    <sect1>
        <title>Roadmap</title>
        <para>
            <itemizedlist>
                <listitem>
                    <para>Components of Salt</para>
                </listitem>
                <listitem>
                    <para>Insides of Salt</para>
                    <para>Only for the ones wants to understand the whole stuff, or for
                        troubleshooting</para>
                    <itemizedlist>
                        <listitem>
                            <para>SRelation and SNode as fathers of the rest</para>
                            <para>when an SNode is deleted its in-and outgoind relations will be
                                deleted too</para>
                        </listitem>
                        <listitem>
                            <para>usage of SFeature in detail</para>
                        </listitem>
                        <listitem>
                            <para>3 Faltigkeit of Salt: salt-graph, salt-core and salt-common</para>
                        </listitem>
                    </itemizedlist>
                </listitem>
                <listitem>
                    <para>Implementors guide (same as Quick users guide)</para>
                    <itemizedlist>
                        <listitem>
                            <para>Code is generated by EMF, everything starts with and e for emf, or
                                with an S for salt</para>
                        </listitem>
                        <listitem>
                            <para>Factory pattern, what is it, how does it work, explain eISNTANCE
                                model</para>
                        </listitem>
                        <listitem>
                            <para>a section easy access (no EMF)</para>
                        </listitem>
                        <listitem>
                            <para>how to traverse a graph</para>
                        </listitem>
                        <listitem>
                            <para>how to create a corpus-structure, with easy access</para>
                        </listitem>
                        <listitem>
                            <para>how to get all out/ in going edges</para>
                        </listitem>
                        <listitem>
                            <para>simple creation methods of SDocumentGraph</para>
                        </listitem>
                    </itemizedlist>
                </listitem>

            </itemizedlist>
        </para>
    </sect1>
     -->
    <itemizedlist>
        <listitem>
            <para>change figures <xref linkend="fig_graph_model"/> and <xref
                    linkend="fig_labelAndGraph"/> and use SRelation with sType, SLabel and so
                on</para>
        </listitem>
    </itemizedlist>
    <sect1 xml:id="sec_intro">
        <title>The aim of Salt</title>
        <para>With Salt we provide an easily understandable meta model for linguistic data and an
            open source api to store, manipulate and represent data. Salt is an abstract model, poor
            of linguistic semantics. As a result, it is free of any linguistic schools or theories.
            The core model is graph-based and therefore keeps the structural restrictions very low
            and allows for a wide range of possible linguistic annotations like syntactic,
            morphological, coreferential annotations and many more. You can even model your own very
            personal annotation as long as it fits into a graph structure (and so far we have not
            seen a linguistic annotation which does not). Furthermore, Salt does not depend on a
            specific linguistic tagset which allows you to use every tagset you like.</para>
        <para>Originally Salt was developed as a common meta model as part of the SaltNPepper project<footnote>
                <para>see <link xlink:href="http://u.hu-berlin.de/saltnpepper"
                        >http://u.hu-berlin.de/saltnpepper</link></para>
            </footnote>. The aim of this project was to develop a converter framework (called
            Pepper) being able to convert several linguistic formats<footnote>
                <para>for instance the PennTreebank format, TigerXML, the EXMARaLDA format, PAULA,
                    GrAF, RST, CoNLL, the ANNIS format and many more</para>
            </footnote> into each other. The job of Salt here was to be able to cover all these
            kinds of data with a single model. In the meantime, Salt was developed further to an own
            project and it now is part of several linguistic software solutions like ANNIS<footnote>
                <para>see <link xlink:href="http://www.sfb632.uni-potsdam.de/annis/"
                        >http://www.sfb632.uni-potsdam.de/annis/</link></para>
            </footnote>, Atomic<footnote>
                <para>see <link xlink:href="http://linktype.iaa.uni-jena.de/atomic/"
                        >http://linktype.iaa.uni-jena.de/atomic/</link></para>
            </footnote>and of course Pepper.</para>
        <para>Salt was developed following a model driven development approach with the use of the
            Eclipse Modeling framework (EMF, see <link
                xlink:href="http://www.eclipse.org/modeling/emf/"
                >http://www.eclipse.org/modeling/emf/</link>). EMF provides a UML near syntax and
            possibilities to automatically generate code for an api. We used the code generation to
            generate Java code and extended the api with many functions for an easier access. This
            makes the api much more specific to the linguistic domain.</para>
        <para>This article addresses a wider range of readers. We want to satisfy readers coming
            from a linguistic background as well as readers coming from a technical background. As
            this is a balancing act between different domains, we try to provide simple additional
            information for specific terms and aspects of the different domains. If you get bored at
            some point, don't hesitate to step over these paragraphs to the more interesting parts.
            We always try to improve our software and guides as well. And since we are an
            open-source community project, this is your chance to participate. So if you find typos
            or misleading parts of text, please let us know and the honor will be yours. Just mail
            to <email>saltnpepper@lists.hu-berlin.de</email>.</para>
    </sect1>
    <sect1 xml:id="sec_graph">
        <title>What is a graph?</title>
        <para>Since Salt is a totally graph based model, it is important to have a basic
            understanding of what a graph is.</para>
        <para>A graph is a very simple, but not very linguistic structure. So we need to abstract
            over linguistic data to press them into such a structure. To give a simple explanation
            of what a graph is, let us forget linguistics for a moment and think about humans, and
            their relationships. Imagine a set of humans for instance your family or friends. In a
            graph, each of these humans will represent one node. The relationship between exactly
            two humans then is defined as an edge. In other words, an edge connects to nodes. Now
            the relations between humans can be very different, so for instance the relation between
            a couple can be described as a love relation, whereas the relation between an employee
            and her/his boss could be described as a work relation. This example shows us that the
            edges between nodes can be very different, as well as human relations could be. To
            differentiate the types of edges, they could be labeled. The same goes for the nodes:
            they also could be labeled, for instance with the human's name it represents. Returning
            to linguistics, this means, when we can model humans and their relationships as a graph,
            we can also model linguistic artifacts as a graph. For instance we can model texts,
            tokens etc. as nodes, linguistic categorization as labels and relations between them as
            edges. In the following, this will become clearer.</para>
        <para>As we now have an informal understanding of what a graph is, we want to deepen it by
            giving a formal definition of what we understand under a graph here. To model Salt, we
            enhanced the general directed graph structure, which is <emphasis role="italic">G= (V,
                E)</emphasis> with: <itemizedlist>
                <listitem>
                    <para><emphasis role="italic">V</emphasis> being a set of nodes and</para>
                </listitem>
                <listitem>
                    <para><emphasis role="italic">E</emphasis> being a set of directed edges with
                            <emphasis role="italic">e= (v<subscript>1</subscript> ∊ V,
                                v<subscript>2</subscript> ∊ V) ∊ E</emphasis>.</para>
                </listitem>
            </itemizedlist>
        </para>
    </sect1>
    <sect1 xml:id="sec_salt">
        <title>What is Salt?</title>
        <para>As already mentioned, Salt is a graph based model, therefore we expanded the graph
            structure presented in <xref linkend="sec_graph"/> with layers and labels and the
            mechanism to label a graph, a node, an edge, a layer or another label. The expanded
            graph structure is given by <emphasis role="italic">G=(V, E, L,
                    {label<subscript>a</subscript>, … label<subscript>b</subscript>})</emphasis>
            with: <itemizedlist>
                <listitem>
                    <para><emphasis role="italic">V</emphasis> being a set of nodes with <emphasis
                            role="italic">v= ({label<subscript>c</subscript>, …
                                label<subscript>d</subscript>}) ∊ V</emphasis></para>
                </listitem>
                <listitem>
                    <para>E being a set of directed edges with <emphasis role="italic">e=
                                (v<subscript>1</subscript> ∊ V, v<subscript>2</subscript> ∊ V,
                                {label<subscript>e</subscript>, … label<subscript>f</subscript>}) ∊
                            E</emphasis></para>
                </listitem>
                <listitem>
                    <para>L being a set of layers with <emphasis role="italic">l=
                                (V<subscript>1</subscript> ⊆ V, E<subscript>1</subscript> ⊆ E,
                                L<subscript>1</subscript> ⊆ L, {label<subscript>g</subscript>,..
                                label<subscript>h</subscript>}) ∊ L</emphasis></para>
                </listitem>
                <listitem>
                    <para>and a set of labels <emphasis role="italic"
                            >{label<subscript>a</subscript>, …
                            label<subscript>b</subscript>}</emphasis> the graph is labeled with<footnote>
                            <para>Note that this set does not contain the labels of the nodes, edges
                                and layers.</para>
                        </footnote>.</para>
                </listitem>
            </itemizedlist>Each label is defined as <emphasis role="italic"
                    >label<subscript>y</subscript>= (namespace, name, value,
                    {label<subscript>k</subscript>,...label<subscript>l</subscript>})</emphasis>. </para>
        <para> A layer is a grouping mechanism for nodes and edges, and can also contain further
            layers (called sub-layers). The containment relation implements a recursive structure
            for layers, to build hierarchies. In general this mechanism enables the creation of
            sub-graphs. But note that a layer cannot be contained by itself, so cycles of layers are
            not possible. </para>
        <para> A label is an attribute-value-pair contained in either a node, an edge, a graph, a
            layer or another label. The attribute-value-pair mechanism is realized by two
            components, a naming component and a value component. The naming component must be
            unique for one object and consists of the two values namespace and name. We expand the
            naming component with a namespace attribute to enable the possibility of adding more
            than one label with the same name to one graph, node etc. Now an object can have two
            labels with the same name but different namespaces. The value component is simpler and
            is just the value itself. The values of namespace and name are restricted to be a String
            value, whereas the value is unbound and can be in principle anything.</para>
        <para>At least we want to regard Salt from a modelling point of view. Therefore <xref
                linkend="fig_graph_model"/> shows the base model, we used for our abstraction for
            linguistic data in EMF. The figure shows, the above defined elements and their
            connection to each other. In Salt, we call a node <classname>SNode</classname>, an edge
                <classname>SRelation</classname>, a layer <classname>SLayer</classname> and a graph
                <classname>SGraph</classname>. <figure xml:id="fig_graph_model">
                <title>Salt base graph model as UML model</title>
                <mediaobject>
                    <imageobject>
                        <imagedata width="350" fileref="images/graph_model.png"/>
                    </imageobject>
                </mediaobject>
            </figure> When you take a look to the figure, you might wonder, what the attribute
                <classname>sType</classname> of element <classname>SRelation</classname>
                (<classname>SRelation.sType</classname>) means, since it is not introduced in the
            formal model and conflicts with the approach that everything we use in Salt must be one
            of the graph elements. Don't worry on that, in fact the <classname>sType</classname> is
            even a label on an edge. We herefore used a specific type of label, the
                <classname>SFeature</classname> element whcih is described in detail in <xref
                linkend="sec_labeling"/>. The <classname>sType</classname> attribute for edges is a
            very since mechanism for linguistic data, since edges do not always need an
            attribute-value pair. Sometimes it is enough to flag an edge being a specific type. If
            this sounds to abstract for now don't worry we give detailed examples in <xref
                linkend="sec_pointingRelation"/> and <xref linkend="sec_hierarchies"/>. <xref
                linkend="fig_labelAndGraph"/> shows the model element label, which in Salt is called
                <classname>SLabel</classname>, and the connection between such a label and the other
            model elements. <figure xml:id="fig_labelAndGraph">
                <title>Label mechanism for graph, node, edge and layer</title>
                <mediaobject>
                    <imageobject>
                        <imagedata width="200" fileref="images/labelAndGraph.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </para>
        <sect2 xml:id="sec_labeling">
            <title>Annotations and label mechanism</title>
            <para>Generally spoken, an annotation is an interpretation of primary data (see <xref
                    linkend="sec_primData"/>). In Salt, we differentiate this abstract form of
                annotation into a "structural" and a "semantic" part. Imagine for instance a syntax
                tree. In Salt, the tree itself, which is modeled by nodes and edges, would belong to
                the structural part, whereas the assignment of a node or an edge to a category like
                being a sentence, a noun phrase etc. belongs to the semantic part. The semantic part
                is realized by labeling a node or an edge for instance by adding a label with the
                name "cat" and value "S" (following the tiger scheme<footnote>
                    <para>see <link
                            xlink:href="http://www.ims.uni-stuttgart.de/forschung/ressourcen/korpora/TIGERCorpus/annotation/tiger_scheme-syntax.pdf"
                            >http://www.ims.uni-stuttgart.de/forschung/ressourcen/korpora/TIGERCorpus/annotation/tiger_scheme-syntax.pdf</link></para>
                </footnote>, where "cat" stands for category and "S" for sentence). Note that such a
                tagset is not part of Salt. Salt is poor of semantics, which means you can use every
                tagset you like.</para>
            <para>We further differentiate between a linguistic annotation and a meta annotation. A
                linguistic annotation defines a structural element as a specific linguistic
                category. A meta annotation adds non-linguistic information to a structural element.
                For instance language information to a primary text, information about an annotator
                of a syntax tree and so on. But still both sorts of annotations are derivates of a
                label and are therefore a triple consisting of a namespace, a name and a value as
                shown in <xref linkend="fig_annotations"/>. <figure xml:id="fig_annotations">
                    <title>Annotations in Salt are specific types of labels</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata width="200" fileref="images/model_annotations.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>
            <para>Since annotations are a core essence of linguistic work, they will be used at
                various places in the following.</para>
            <para>Next to <classname>SAnnotation</classname> and
                    <classname>SMetaAnnotation</classname>, there are two further subtypes of
                    <classname>Label</classname>. One is
                    <classname>SProcessingAnnotation</classname> and the other is
                    <classname>SFeature</classname>. The type
                    <classname>SProcessingAnnotation</classname> is not part of the model, this type
                could be used, to add some information to any Salt object during a processing. So
                for instance you can store any state like '<emphasis role="italic">already
                    processed</emphasis>' or other non-linguistic and non meta annotations like
                'having the color red'<footnote>
                    <para>For instance if you compute the chromatic number of the linguistic
                        graph.</para>
                </footnote> to it. Unfortunately the label <classname>SFeature</classname> is a bit
                more complicated. The good news is, that you normally will not need to work with it,
                when using the Salt api. The <classname>Sfeature</classname> is a mechanism to
                enhance our graph elements with class attributes<footnote>
                    <para>In UML or object oriented programming languages an attribute is part of a
                        class to store a state of a class instance.</para>
                </footnote>. We will explain this is more detail in <xref linkend="sec_sfeature"/>,
                but mention it at this place, since we have already used it for
                    <classname>Srelation.sType</classname> and will use it in the following
                sections.</para>
            <para> If it is not clear what this has to do with modeling linguistic data, we hope to
                make it clear in the following sections. But always keep in mind, that everything in
                Salt and all its power is reducible, to the here presented graph structure. And
                since the nodes and edges in Salt are just used as placeholders, the real power and
                especially the linguistic power comes from the labeling mechanism, which is widely
                used in Salt as you will see in the following.</para>
        </sect2>
    </sect1>
    <sect1>
        <title>Components</title>
        <para>This section addresses the single components of Salt and the linguistic aspects they
            are covering. This section is divided into two parts, the corpus-structure and the
            document-stcuture. The corpus-structure is a grouping mechanism, to organize a corpus,
            whereas the document-structure covers the 'real' linguistic part.</para>
        <sect2 xml:id="sec_corpusStructure">
            <title>Corpus-structure</title>
            <para> A corpus-structure structures an entire corpus into smaller logical units. Such
                units are a corpus, a subcorpus and a document. Often the structurization goes along
                the logical structure of the real data. Imagine your corpus represents a collection
                of writings of an author, then you may have one subcorpus per writing, which itself
                contains subcorpora representing the chapters or articles, which again might be
                divided into paragraphs etc.. Dividing data has two main benefits, a logical and a
                practical. From a logical point of view, the corpus-structure keeps the hierarchical
                relation of units as given in the real world item. And from a practical point of
                view, it keeps things simple. For instance several human annotators can work on
                several units in parallel. Furthermore this will also speed up automatic processing,
                since data fit easier into main memory and indexes on them can be kept small. </para>
            <sect3>
                <title>Corpus</title>
                <para>As mentioned above, a corpus is an element to organize your data. Similar to a
                    folder in a filesystem, it groups the underlying parts (files and other
                    folders). Abstractly spoken, a corpus is a selfcontaining structure which
                    contains documents or further corpora. When a corpus contains another corpus, we
                    call the container corpus the super-corpus and the contained corpus the
                    sub-corpus. A corpus which is not contained by another corpus is called a root
                    corpus. Each corpus can contain an unbound number of corpora. With this
                    mechanism we now can represent a hierarchy as mentioned above. A corpus
                    representing a collection of writings can contain further corpora, each
                    representing a book. A book corpus itself can contain corpora representing a
                    chapter, and so on. In Salt, a corpus is represented by a
                        <classname>SCorpus</classname> element. Two <classname>SCorpus</classname>
                    objects can be set into super-corpus sub-corpus relation via connecting them
                    with a <classname>SCorpusRelation</classname> object. </para>
            </sect3>
            <sect3 xml:id="sec_document">
                <title>Document</title>
                <para>A document is a logical partition which represents the end point of the
                    corpus-structure hierarchy. Partitioning data means that no relations between
                    data of two partitions are allowed. More concretely spoken, a document normally
                    contains a single text and all annotations corresponding to it, but no
                    interlinks between two texts or their annotations. A text can be a paragraph, a
                    chapter, an article or even an entire book. But a text can also be understood as
                    the logical interpretation of it and be realized in several languages (called
                    parallel text), or in case of historical texts in several normalized or
                    diplomatic surrogates. These texts are often interlinked between same tokens
                    (here 'same' means the same meaning, for instance in different languages). In
                    that case all surrogates of a text <emphasis role="bold">HAVE TO</emphasis>
                    belong to the same partition (document). Next to a logical partitioning,
                    creating such documents has a high influence on processing speed and main
                    memory. Therefore we highly recommend to keep documents as small as possible (as
                    long as allowed by the linguistic logic behind). A document in Salt is
                    represented by the type <classname>SDocument</classname> and can be grouped to a
                    corpus or subcorpus by attaching it to a <classname>SCorpus</classname>. To mark
                    a <classname>SDocument</classname> as being part of a
                        <classname>SCorpus</classname>, just connect them via a
                        <classname>SDocumentCorpusRelation</classname>.</para>
            </sect3>
            <sect3 xml:id="sec_corpusGraph">
                <title>Corpus-Graph</title>
                <para>Since Salt is graph based over and over, the corpus-structure is represented
                    as a graph, called the <classname>SCorpusGraph</classname>. This graph realizes
                    a directed tree structure, whose nodes are corpora
                        (<classname>SCorpus</classname>) and documents
                        (<classname>SDocument</classname>) as shown in <xref
                        linkend="fig_corpusStructure"/>. <figure xml:id="fig_corpusStructure">
                        <title>Elements being part of the corpus-structure</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata width="200" fileref="images/model_corpusGraph.png"/>
                            </imageobject>
                        </mediaobject>
                    </figure>For those who prefer samples over UML diagrams, <xref
                        linkend="fig_sample_corpusStructure"/> shows a sample containing three
                        <classname>SCorpus</classname> objects "superCorpus", "subCorpus1" and
                    "subCorpus2" and four <classname>SDocument</classname> objects "doc1", "doc2",
                    "doc3" and "doc4". Two objects of type <classname>SCorpusRelation</classname>
                    connect the "superCorpus" with "subCorpus1" and "subCorpus2". Four objects of
                    type <classname>SDocumentCorpusRelation</classname> connect the sub-corpus
                    "subCorpus1" with documents "doc1" and "doc2" and sub-corpus "subCorpus2" with
                    documents "doc3" and "doc4".<figure xml:id="fig_sample_corpusStructure">
                        <title>Elements being part of the corpus-structure</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata width="200" fileref="images/sample_corpusStructure.png"/>
                            </imageobject>
                        </mediaobject>
                    </figure>
                </para>
            </sect3>
            <sect3 xml:id="sec_metaAnnotation">
                <title>Meta annotations</title>
                <para>Meta annotations are very useful for corpora to document, for instance, the
                    creation process or the aim of the corpus. These information are supposed to
                    give a person working with this corpus additional non-linguistic information.
                    For instance which tools have been used, which persons have annotated the
                    corpus, when was the corpus annotated and so on. Let's give an example: a meta
                    annotation describing an author having the <varname>SName</varname> '<emphasis
                        role="italic">author</emphasis>', the <varname>SValue</varname> '<emphasis
                        role="italic">John Doe</emphasis>' and an empty <varname>SNS</varname> can
                    be added to a <classname>SCorpus</classname> node to mark that this corpus is
                    created by '<emphasis role="italic">John Doe</emphasis>' for instance. Salt is
                    an open model, which means, there are no limitations on naming a meta
                    annotation. Further, Salt does not interpret them, therefore the meta annotation
                    for determining the author can also be named '<emphasis role="italic"
                        >creator</emphasis>' or something else instead of '<emphasis role="italic"
                        >author</emphasis>'. </para>
                <para> The most convenient way to use meta annotations is to add a meta annotation
                    to a document or a corpus node. But since a meta annotation is just a label of a
                    specific type, you are free to add it to each node or edge in the Salt model.
                </para>
            </sect3>
        </sect2>
        <sect2 xml:id="sec_documentStructure">
            <title>Document-structure</title>
            <para/>
            <sect3 xml:id="sec_primData">
                <title>Primary data</title>
                <para>The primary data in linguistics are the center and the beginning of each
                    annotation process. Every piece of language is a primary date. This includes
                    textual data, audio-video data etc. . A special subtype of primary data is the
                    primary text, which only covers textual data. Since in linguistics the term and
                    the meaning of primary data and especially primary text is controversial, we
                    here use primary data as the first digitalisation of data which come into a Salt
                    model.</para>
                <para>So now the question is how to realize primary data in a graph based world. And
                    the answer is: with graph elements, or more precisely with nodes and labels. In
                    Salt, a specific node of type <classname>SDatasource</classname> is used as a
                    placeholder for a primary date. The real data itself is added to that node with
                    a label having the name <varname>sData</varname> and the namespace <emphasis
                        role="italic">salt</emphasis>. The same goes for each subtype of
                        <classname>SDatasource</classname>, so for instance for the type
                        <classname>STextualDS</classname> which represents primary texts in Salt,
                    see <xref linkend="fig_primaryData"/>.</para>
                <figure xml:id="fig_primaryData">
                    <title>Primary data and primary text in Salt</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata width="200" fileref="images/model_primaryData.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>Regarding <xref linkend="fig_primaryData"/> the primary text like '<emphasis
                        role="italic">Is this example more complicated than it appears to
                        be?'</emphasis> is stored as the value of the shown
                        <classname>SFeature</classname>.</para>
            </sect3>
            <sect3 xml:id="sec_tokenization">
                <title>Tokenization</title>
                <para>In general, it is not totally clear in linguistics what a token is. In most
                    interpretations the term is used synonymously with 'word'. But even here, the
                    question what a word is, is controverisal. Therefore we here use a more
                    technically definition of what a token is. In Salt a token is the smallest
                    countable unit of primary data. For instance in a primary text, a token could be
                    a set of characters, just one character or even an empty character. This allows
                    us, to use tokens free of a semantical interpretation. A token now can be a
                    word, a silible, a sentence or any other textual categorization.</para>
                <para>The Salt type representing a token is the type <classname>SToken</classname>,
                    a specialization of the type <classname>SNode</classname>. Such a
                        <classname>SToken</classname> object is a placeholder for annotations and a
                    target for interlinking. The <classname>SToken</classname> object itself does
                    not contain any information about the overlapped primary data. In case of the
                    primary data being text, this is realized with a specific type of
                        <classname>SRelation</classname>, the
                        <classname>STextualRelation</classname>. A
                        <classname>STextualRelation</classname> links a primary text (as source)
                    with a token (as target), see <xref linkend="fig_model_token"/>. <figure
                        xml:id="fig_model_token">
                        <title>Representation of tokens in Salt via <classname>SToken</classname>
                            and <classname>STextualRelation</classname></title>
                        <mediaobject>
                            <imageobject>
                                <imagedata width="120" fileref="images/model_token.png"/>
                            </imageobject>
                        </mediaobject>
                    </figure> A <classname>STextualRelation</classname> further contains two labels
                    (or more precisely <classname>SFeature</classname> objects) representing the
                    start and the end position determining the interval of the primary text
                    overlapped by the token. Although the type
                        <classname>STextualRelation</classname> has the properties
                        <varname>sStart</varname> and <varname>sEnd</varname>, they are modeled as
                    derived attributes in order to have easier access on these values. <xref
                        linkend="fig_model_token_features"/> shows that mechanism.<figure
                        xml:id="fig_model_token_features">
                        <title>Start and end position for text intervals realized with
                                <classname>SFeature</classname></title>
                        <mediaobject>
                            <imageobject>
                                <imagedata width="200" fileref="images/model_token_features.png"/>
                            </imageobject>
                        </mediaobject>
                    </figure>
                </para>
                <para>Finally, <xref linkend="fig_sample_tokenization"/> gives an example of a
                    tokenization of the primary text '<emphasis role="italic">Is this example more
                        complicated than it appears to be?</emphasis>'. <figure
                        xml:id="fig_sample_tokenization">
                        <title>A sample tokenization</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata width="400" fileref="images/sample_tokenization.png"/>
                            </imageobject>
                        </mediaobject>
                    </figure></para>
            </sect3>
            <sect3 xml:id="sec_annotation">
                <title>Annotations</title>
                <para>In the last sections we showed how to model the structural part of
                    annotations. Here we want to give an impression of how to do the semantic part
                    of it. Therefore we pick up the sample of <xref linkend="sec_tokenization"/> and
                    especially its tokenization. We want to enhance the tokenized words with
                    part-of-speech annotations. We already introduced the labeling mechanism in
                        <xref linkend="sec_labeling"/>. Now we want to make use of it by adding a
                        <classname>SAnnotation</classname> object to each token having the
                        <classname>sName</classname> '<emphasis role="italic">pos</emphasis>' and
                    the corresponding part-of-speech value as <classname>sValue</classname>. <xref
                        linkend="fig_sample_token_annotation"/> shows the annotation for the
                    previous used tokenization. <figure xml:id="fig_sample_token_annotation">
                        <title>Part-of-speech annotations of sample tokenization</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata width="400" fileref="images/sample_tokenization_pos.png"/>
                            </imageobject>
                        </mediaobject>
                    </figure>Each of these annotations are reducable to labels of type
                        <classname>SAnnotation</classname> and <xref
                        linkend="fig_sample_token_annotation_pos"/> examplifies the annotation of
                    token t<subscript>1</subscript> covering the text '<emphasis role="italic"
                        >is</emphasis>' with a part-of-speech annotation.<figure
                        xml:id="fig_sample_token_annotation_pos">
                        <title>Part-of-speech annotation '<emphasis role="italic">VBZ</emphasis>'
                            for token t<subscript>1</subscript></title>
                        <mediaobject>
                            <imageobject>
                                <imagedata width="200" fileref="images/sample_pos_annotation.png"/>
                            </imageobject>
                        </mediaobject>
                    </figure> We here examplified the creation of annotations using the sample of
                    part-of-speech annotations and tokens. But remember, that Salt is not bound to a
                    specific set of annotations or tagsets. This means, you can use any kind of
                    annotations with the same machanism. Furthermore adding an
                        <classname>SAnnotation</classname> is not bound to tokens. Also any
                        <classname>SNode</classname>, <classname>SRelation</classname>,
                        <classname>SLayer</classname>, <classname>SGraph</classname> and even
                        <classname>SAnnotation</classname> can be annotated in this way.
                    <!-- explain SPOSAnnotation and mention SLemmaAnnotation and all availables; explain ISOCat mechanism when ready -->
                </para>
            </sect3>
            <sect3 xml:id="sec_spans">
                <title>Spans of tokens</title>
                <para>A span is used to group a couple of tokens together to give them exactly the
                    same annotation or to connect them as a bunch with a 3rd node at once. A span is
                    an ordered set of tokens. </para>
                <para>Let s<subscript>1</subscript> be a span, for each token
                        t<subscript>1</subscript> and t<subscript>2</subscript> ∊
                        s<subscript>1</subscript>: t<subscript>1</subscript> !=
                        t<subscript>2</subscript> --> t<subscript>1</subscript> &lt;
                        t<subscript>2</subscript> XOR t<subscript>2</subscript> &lt;
                        t<subscript>1</subscript>. </para>
                <para>In a graph based world, we need to model such an ordered set as nodes and
                    edges. Therefore Salt provides the node type <classname>SSpan</classname> and
                    the relation type <classname>SSpanningRelation</classname>. A
                        <classname>SSpan</classname> object represents the span itself and for
                    instance could be annotated or linked with other nodes. To realize the
                    containment of tokens in a span, each token is connected with the span with a
                    separate <classname>SSpanningRelation</classname> object, see <xref
                        linkend="fig_model_span"/>. <figure xml:id="fig_model_span">
                        <title>Relation of spans in Salt via <classname>SSpan</classname> and
                                <classname>SSpanningRelation</classname></title>
                        <mediaobject>
                            <imageobject>
                                <imagedata width="150" fileref="images/model_span.png"/>
                            </imageobject>
                        </mediaobject>
                    </figure>
                </para>
                <para>Imagine a piece of a primary text like '<emphasis role="italic">New
                        York</emphasis>' and two tokens <emphasis role="italic"
                            >t<subscript>1</subscript></emphasis> (representing '<emphasis
                        role="italic">New</emphasis>') and <emphasis role="italic"
                            >t<subscript>2</subscript></emphasis> (representing '<emphasis
                        role="italic">York</emphasis>'). For annotating them as an entity, you can
                    create a span <emphasis role="italic">s<subscript>1</subscript></emphasis> and
                    connect <emphasis role="italic">t<subscript>1</subscript></emphasis> with
                        <emphasis role="italic">s<subscript>1</subscript></emphasis> via one
                        <classname>SSpanningRelation</classname>
                    <emphasis role="italic">r<subscript>1</subscript></emphasis> and <emphasis
                        role="italic">t<subscript>2</subscript></emphasis> with <emphasis
                        role="italic">s<subscript>1</subscript></emphasis> via a second
                        <classname>SSpanningRelation</classname>
                    <emphasis role="italic">r<subscript>2</subscript></emphasis> as shown in <xref
                        linkend="fig_sample_span"/>. <figure xml:id="fig_sample_span">
                        <title>'New York'-sample as Salt objects</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata width="100" fileref="images/sample_span.png"/>
                            </imageobject>
                        </mediaobject>
                    </figure> Since a <classname>SSpan</classname> is just a node, it can be further
                    annotated for instance with an annotation '<emphasis role="italic">entity=
                        city</emphasis>'. Spans can even be very helpful to annotate bigger parts of
                    the primary text, for instance to annotate information structure or foreign
                    language parts etc. . Also a <classname>SSpanningRelation</classname> can carry
                    further annotations, but this is rather unusual since such an edge has no own
                    linguistic semantics and is just a technical mechanism to model ordered sets in
                    a graph.</para>
            </sect3>
            <sect3 xml:id="sec_hierarchies">
                <title>Hierarchies</title>
                <para>Hierarchies are a useful mechanism in linguistics to express a complex
                    structure behind the surface of a text. For instance, a widely used mechanism to
                    describe phrase structures are syntax trees. The term syntax trees implies that
                    these hierarchies are trees, even in a graph sense. Which means, they consists
                    of nodes and edges and are therefore easy to model in Salt. Salt offers a
                    specific kind of node, the <classname>SStructure</classname>, and a specific
                    kind of edge, the <classname>SDominanceRelation</classname>. The source of an
                        <classname>SDominanceRelation</classname> object always is a
                        <classname>SToken</classname>, <classname>SSpan</classname> or even a
                        <classname>SStructure</classname> object as shown in <xref
                        linkend="fig_model_hierarchie"/>. The unit of both elements enables to
                    create unbound hierarchies above a tokenization. </para>
                <figure xml:id="fig_model_hierarchie">
                    <title>Hierarchies in Salt are modeled with the elements
                            <classname>SStructure</classname> and
                            <classname>SDominanceRelation</classname></title>
                    <mediaobject>
                        <imageobject>
                            <imagedata width="100" fileref="images/model_hierarchies.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>The meaning of the type <classname>SDominanceRelation</classname> is a part-of
                    relation. In contrast to the <classname>SSpan</classname> and the
                        <classname>SSpanningRelation</classname>, a
                        <classname>SStructure</classname> is not just a placeholder for a bunch of
                        <classname>SToken</classname> objects, it is a proper element itself. The
                    same goes for <classname>SDominanceRelation</classname> objects. For instance,
                    in many cases it makes a linguistic difference whether tokens <emphasis
                        role="italic">t<subscript>1</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>2</subscript></emphasis> and <emphasis role="italic"
                            >t<subscript>3</subscript></emphasis> are directly dominated by a
                    structure <emphasis role="italic">s<subscript>1</subscript></emphasis> or
                    whether <emphasis role="italic">t<subscript>1</subscript></emphasis> and
                        <emphasis role="italic">t<subscript>2</subscript></emphasis> are dominated
                    by a structure <emphasis role="italic">s<subscript>2</subscript></emphasis>
                    which is, together with <emphasis role="italic"
                        >t<subscript>3</subscript></emphasis>, dominated by structure <emphasis
                        role="italic">s<subscript>2</subscript></emphasis>, see <xref
                        linkend="fig_sample_hierarchie1"/> and <xref
                        linkend="fig_sample_hierarchie2"/>.</para>
                <figure xml:id="fig_sample_hierarchie1">
                    <title>Syntax tree 1</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata width="100" fileref="images/sample_hierarchies1.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <figure xml:id="fig_sample_hierarchie2">
                    <title>Syntax tree 2</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata width="100" fileref="images/sample_hierarchies2.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </sect3>
            <sect3 xml:id="sec_pointingRelation">
                <title>Loose relation</title>
                <para>Sometimes it is necessary to set objects into a very loose relationship, into
                    a kind of an interlinking, which does not influence the objects themselves. Such
                    a relation is the type <classname>SPointingRelation</classname>. A pointing
                    relation in Salt allows to relate any kind of nodes with each other. In general,
                    this type of relation has no semantics and could be used for a wide range of
                    annotations, which does not group or structure nodes. For instance, this could
                    be very helpful for a dependency analysis or coreferences etc. . </para>
                <para>To give an example, imagine the text '<emphasis role="italic">John ...
                        he</emphasis>', where '<emphasis role="italic">John</emphasis>' (token
                        <emphasis role="italic">t<subscript>1</subscript></emphasis>) and '<emphasis
                        role="italic">he</emphasis>' (token <emphasis role="italic"
                            >t<subscript>2</subscript></emphasis>) refer to the same entity. To
                    express that in Salt, you can create a <classname>SPoiningRelation</classname>
                    object having the <classname>sSource</classname>
                    <emphasis role="italic">t<subscript>1</subscript></emphasis> and the
                        <classname>sTarget</classname>
                    <emphasis role="italic">t<subscript>2</subscript></emphasis>, or the other way
                    around. Now let's extend this example and imagine the text '<emphasis
                        role="italic">John Doe ... he</emphasis>', with the tokens <emphasis
                        role="italic">t<subscript>1</subscript></emphasis> ('<emphasis role="italic"
                        >John</emphasis>'), <emphasis role="italic"
                        >t<subscript>2</subscript></emphasis> ('<emphasis role="italic"
                        >Doe</emphasis>') and <emphasis role="italic"
                        >t<subscript>3</subscript></emphasis> ('<emphasis role="italic"
                        >he</emphasis>'). In this case, we want to set '<emphasis role="italic">John
                        Doe</emphasis>' as a whole in relation to '<emphasis role="italic"
                        >he</emphasis>'. This is possible by creating a <classname>SSpan</classname>
                    object <emphasis role="italic">s<subscript>1</subscript></emphasis> containing
                        <emphasis role="italic">t<subscript>1</subscript></emphasis> and <emphasis
                        role="italic">t<subscript>2</subscript></emphasis> and relating the token
                        <emphasis role="italic">t<subscript>3</subscript></emphasis> via a
                        <classname>SPointingRelation</classname> object to <emphasis role="italic"
                            >s<subscript>1</subscript></emphasis>.</para>
                <para>Just like all other relations, <classname>SPointingRelation</classname> can be
                    annotated to express some linguistic semantics. If there is no
                    attribute-value-pair and just a single value like to determine this is a
                    coreferential relation or a dependency, you can use the <varname>sType</varname>
                    attribute which is available for every <classname>SRelation</classname>. </para>
            </sect3>
            <sect3 xml:id="sec_layer">
                <title>Layer</title>
                <para>A layer is a simple grouping mechanism for bundling nodes and edges to a set.
                    In graph theory, a layer is equivalent to a subgraph. Such a layer could be very
                    helpful for linguistic data to distinguish between several kinds of annotations
                    or annotation graphs. Imagine for instance a document-structure containing a set
                    of tokens and a syntax tree. Now it might be helpful for your model to
                    distinguish between these nodes. For instance when you group the tokens to a
                    morphological layer and the nodes, being part of the syntactic tree, are grouped
                    to a syntactic layer. You now might ask: "Why should I?" I can distinguish them
                    by their type. And you are right in that case. But when nodes belong to the same
                    type, but to different semantics, you need an explicit grouping mechanism.
                    Imagine a set of spans annotating the information structure of a text and
                    another set of spans annotating the typological fields.</para>
                <para>In Salt, each node and each edge can belong to an unbound number of layers.
                    Furthermore, a layer can also contain a layer. Imagine our first example. Here
                    the syntactic layer can contain the morphological layer, and as a result, all
                    tokens are part of the syntactic layer as well. A layer is represented with the
                    element <classname>SLayer</classname> has a name and can be annotated in the
                    same way as nodes and edges can be. <xref linkend="fig_sLayers"/> shows the
                    relationship between layers nodes and edges in Salt. <figure
                        xml:id="fig_sLayers">
                        <title><classname>SLayer</classname> as a subgraph</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata width="200" fileref="images/sLayers.png"/>
                            </imageobject>
                        </mediaobject>
                    </figure>
                </para>
            </sect3>
            <sect3 xml:id="sec_multipleTexts">
                <title>Multiple primary texts</title>
                <subtitle>parallel texts</subtitle>
                <para>A lot of corpus projects in linguistics are more complex than handling just
                    one primary text. They address parallel data dealing with multiple texts, for
                    instance to compare different languages, different XXX Sprachstufen XXX or to
                    handle dialogue data with multiple speakers. In Salt the number of primary texts
                    (element <classname>STextualDS</classname>) or primary data (element
                        <classname>SDataSource</classname>) is not limited. </para>
                <para>We want to demonstrate the use of multiple texts by creating a parallel corpus
                    for the languages English and German. Demonstrations how to model different XXX
                    Sprachstufen XXX and dialogue data please take a look to <xref
                        linkend="sec_time"/> and <xref linkend="sec_order"/>. Imagine the primary
                    text '<emphasis role="italic">Is this example more complicated than it appears
                        to be?'</emphasis> and its German translation '<emphasis role="italic">Ist
                        dieses Beispiel komplizierter als es zu sein scheint?</emphasis>'. Creating
                    two <classname>STextualDs</classname> objects '<emphasis role="italic"
                        >text1</emphasis>' and '<emphasis role="italic">text2</emphasis>' containing
                    the one of the texts each is rather simple<footnote>
                        <para>Each primary text is is stored in the attribute
                                <classname>STextualDS.sText</classname>, see <xref
                                linkend="sec_primData"/></para>
                    </footnote> and the more interesting question is how to align the single words
                    as being translations of each other. In case you are not so familar with German<footnote>
                        <para>By the way what is a pitty.</para>
                    </footnote>, we here present the translation alignment for the tokenized
                    texts:<programlisting>Is    this     example    more complicated   than   it   appears   to   be?
Ist   dieses   Beispiel   komplizierter      als    es   scheint   zu   sein?'</programlisting>
                    Next to the fact, that English and German are sometimes very close to each other
                    and for our example mostly have a word to word translation, we also have one
                    case, where the two English words '<emphasis role="italic">more
                        complicated</emphasis>' are translated to a single German word '<emphasis
                        role="italic">komplizierter</emphasis>'. To bring two tokens for instance
                        <emphasis role="italic">t<subscript>1e</subscript></emphasis> and <emphasis
                        role="italic">t<subscript>1g</subscript></emphasis> in relation to each
                    other, you can create a <classname>SPointingRelation</classname>
                    <emphasis role="italic">r<subscript>1</subscript></emphasis> which's source is
                        <emphasis role="italic">t<subscript>1e</subscript></emphasis> and target is
                        <emphasis role="italic">t<subscript>1g</subscript></emphasis>. Now they are
                    connected, but more in a technical than in a semantic way. To also the linguisic
                    meaning to that relation, you can use the value
                        <classname>SPointingRelation.sType</classname> and add for instance the type
                        '<classname>translation</classname>'. For such a sample, our linguistic
                    intention to determine that <emphasis role="italic"
                        >t<subscript>1e</subscript></emphasis> is the translation of <emphasis
                        role="italic">t<subscript>1g</subscript></emphasis> and even the way around,
                    the graph structure differs in detail. As our graph is a directed graph, we do
                    not really have such a bidirectional relation. Depending on the interpretation
                    of the corpus, it might be useful to create a second relation having <emphasis
                        role="italic">t<subscript>1g</subscript></emphasis> as source and <emphasis
                        role="italic">t<subscript>1e</subscript></emphasis> as target and to mark
                    both relations as '<emphasis role="italic">trans_en_de</emphasis>' and
                        '<emphasis role="italic">trans_de_en</emphasis>'.</para>
                <para>Now comming to the more complex case of aligning the tokens <emphasis
                        role="italic">t<subscript>4e</subscript></emphasis> ('<emphasis
                        role="italic">more</emphasis>'), <emphasis role="italic"
                            >t<subscript>5e</subscript></emphasis>('<emphasis role="italic"
                        >complicated</emphasis>') with <emphasis role="italic"
                            >t<subscript>4g</subscript></emphasis> ('<emphasis role="italic"
                        >komplizierter</emphasis>'). To realize such an 1:n translation, we
                    recommand to use a span. With a span <emphasis role="italic"
                            >s<subscript>1e</subscript></emphasis> you can group the tokens
                        <emphasis role="italic">t<subscript>4e</subscript></emphasis> and <emphasis
                        role="italic">t<subscript>5e</subscript></emphasis>. This allows to use
                        <emphasis role="italic">s<subscript>1e</subscript></emphasis> as source of
                    the <classname>SPointingRelation</classname> and the token <emphasis
                        role="italic">t<subscript>4g</subscript></emphasis> as its target. </para>
                <para>If your individual case is even more complicated and needs to realize an n:m
                    translation, just use spans on both sides. Group the tokens of the first
                    language to a span and groupt the tokens of the second language to a span. Then
                    connect both spans with a <classname>SPointingRelation</classname>. </para>
                <para>In our sample we used just two languages for a better readability. Note that
                    Salt is not bound to a fixed number of primary texts, which allows to model as
                    many parallel texts with as many relations between their tokenizations as you
                    like. For a well-arranged model, you can group all tokens and the primary text
                    belonging to one language into one layer setting
                        <classname>SLayer.sName</classname> to the language.</para>
            </sect3>
            <sect3 xml:id="sec_time">
                <title>Time management</title>
                <subtitle>dialogue data</subtitle>
                <note>
                    <para>compare that with
                        https://korpling.german.hu-berlin.de/p/projects/saltnpepperinternal/wiki/Salt_timeDiscussion</para>
                </note>
                <para>In this section, we address the time management in Salt. But what does it
                    mean, time management? Remember, Salt is poor of semantics, so time management
                    does not address the timely progression of a text like "<emphasis role="bold"
                        >Before</emphasis> Bart went to school, he stood up."<footnote>
                        <para>The modeling of such semantic issues is up to the user, for instance
                            the ISO approach of TimeML (see XXX) covers that.</para>
                    </footnote> With time management we mean the fact of ordering tokens in a
                    primary text along their temporal occurance. This often becomes necessary for
                    multiple texts. In Salt this is handled by introducing a global<footnote>
                        <para>Global here means global for one document-structure.</para>
                    </footnote> unique timeline which is connected with each token. The timeline in
                    Salt is represented by the element <classname>STimeline</classname> and can be
                    related with tokens via <classname>STimelineRelation</classname> objects. In
                        <xref linkend="sec_multipleTexts"/> we discussed the mechanism of how to
                    model multiple primary texts in Salt. Now we wan't to introduce Salts time
                    management along the example of modelling dialogue data. </para>
                <para>A lot of linguistic projects do not only address written texts, they further
                    annotate spoken data. Spoken data differs in two main issues from written data.
                    First, the data source differs, since the primary data of spoken data is mostly
                    an audio or video stream. Since Salt was developed for covering textual data,
                    for now, we expect that there is also a textual representation of the audio or
                    video data. But nevertheless Salt also allows to represent such data. The
                    mechanism how is addressed in detail in <xref linkend="sec_audioData"/>. Second,
                    in many cases we do not have one continuous text, since there are multiple
                    speakers, which might speak at the same time. We recommand to model each text,
                    belonging to one speaker, in a separate <classname>STextualDS</classname>
                    object. To give a more concrete example, imagine the following to texts produced
                    by speakers '<emphasis role="italic">spk1</emphasis>' and '<emphasis
                        role="italic">spk2</emphasis>': <table frame="all" xml:id="table_overview">
                        <title>Two speakers ('<emphasis role="italic">spk1</emphasis>' and
                                '<emphasis role="italic">spk2</emphasis>') and the corresponding
                            timeline (<emphasis role="italic">tml</emphasis>)</title>
                        <tgroup align="left" cols="10" colsep="1" rowsep="1">
                            <colspec colname="c1" colnum="1"/>
                            <colspec colname="c2" colnum="2"/>
                            <colspec colname="c3" colnum="3"/>
                            <colspec colname="c4" colnum="4"/>
                            <colspec colname="c5" colnum="5"/>
                            <colspec colname="c6" colnum="6"/>
                            <colspec colname="c7" colnum="7"/>
                            <colspec colname="c8" colnum="8"/>
                            <colspec colname="c9" colnum="9"/>
                            <colspec colname="c10" colnum="10"/>
                            <colspec colname="c11" colnum="11"/>
                            <colspec colname="c12" colnum="12"/>
                            <tbody>
                                <row>
                                    <entry>spk1:</entry>
                                    <entry>Is</entry>
                                    <entry>this</entry>
                                    <entry>example</entry>
                                    <entry>more</entry>
                                    <entry>complicated</entry>
                                    <entry>than</entry>
                                    <entry>it</entry>
                                    <entry>appears</entry>
                                    <entry>to</entry>
                                    <entry>be</entry>
                                </row>
                                <row>
                                    <entry>spk2: </entry>
                                    <entry namest="c2" nameend="c8"/>
                                    <entry namest="c8" nameend="c9">Uhm</entry>
                                    <entry>oh</entry>
                                    <entry>yes</entry>
                                </row>
                                <row>
                                    <entry>tml:</entry>
                                    <entry>0-1</entry>
                                    <entry>1-2</entry>
                                    <entry>2-3</entry>
                                    <entry>3-4</entry>
                                    <entry>4-5</entry>
                                    <entry>5-6</entry>
                                    <entry>6-7</entry>
                                    <entry>7-8</entry>
                                    <entry>8-9</entry>
                                    <entry>9-10</entry>
                                    <entry>10-11</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table> This sample shows the tokenized texts of the two speakers and the
                    correspondance of each token, two an interval in the timeline. For instance the
                    token '<emphasis role="italic">Is</emphasis>' (<emphasis role="italic"
                            >t<subscript>1</subscript></emphasis>) of speaker '<emphasis
                        role="italic">spk1</emphasis>' corresponds to an interval starting at 0 and
                    ending at 1<footnote>
                        <para>In Salt the interval borders are also known as point-of-time.</para>
                    </footnote>. Since we are in a graph world, this needs to be modeled by nodes,
                    edges and labels. Therefore, the <classname>STimeline</classname> is a subtype
                    of <classname>SNode</classname> and the <classname>STimelineRelation</classname>
                    is a subtype of <classname>SRelation</classname> having two attributes
                        (<classname>SFeature</classname> objects) <classname>sStart</classname> and
                        <classname>sEnd</classname> determining the borders of the time interval.
                    This is shown in <xref linkend="fig_time"/>
                    <figure xml:id="fig_time">
                        <title>Token 'Is' related to common timeline</title>
                        <mediaobject>
                            <imageobject>
                                <!-- Object diagram SToken 'Is' sTimerel, stimeline and sData(=,1,2,3,4...) and stimerelation sstart=0, send= 1-->
                                <imagedata width="350" fileref="images/graph_model.png"/>
                            </imageobject>
                        </mediaobject>
                    </figure> This mechanism is quite simple, since it is the same mechanism as the
                    way of corresponding a token to a primary text. It might become more interesting
                    in case of the time interval between 7 and 9. In that case the text of
                        '<emphasis role="italic">spk1</emphasis>' covers two tokens (<emphasis
                        role="italic">t<subscript>spk1_8</subscript></emphasis> and <emphasis
                        role="italic">t<subscript>spk1_9</subscript></emphasis>), and the text of
                        '<emphasis role="italic">spk2</emphasis>' (<emphasis role="italic"
                            >t<subscript>spk2_1</subscript></emphasis>) covers one token. But
                    modelling this is also very straight forward, because you can connect them via
                    three <classname>STimeRelation</classname> objects. For <emphasis role="italic"
                            >t<subscript>spk1_8</subscript></emphasis> with the interval [7, 8],
                        <emphasis role="italic">t<subscript>spk1_9</subscript></emphasis> with the
                    interval [8, 9] and finally for <emphasis role="italic"
                            >t<subscript>spk2_1</subscript></emphasis> with the interval [7, 9].
                    With these abstract points-of-time (like 1,2,3,4, ...), it is possible to set an
                    unbound number of tokens and primary texts in relation to the common timeline.
                    In theory, the timeline in Salt is implicitly always there, even in a single
                    primary text, it could be easily computed by the order of the tokens given by
                    the text. But in real implementation, it is not explicitly given if not needed
                    to save memory space. When dealing with audio and video data it might be
                    necessary, not only to use abstract points-of-time (like 1,2,3,4,...), but
                    specific ones (like 00:00:00, 00:00:01, 01:12:20 etc.) as well. How to model
                    such specific intreval borders we show in <xref linkend="sec_audioData"
                    />.</para>
            </sect3>
            <sect3 xml:id="sec_order">
                <title>Ordering tokens</title>
                <para>In this section we address the order of tokens in one or multiple texts. In a
                    single ordinary primary text, the order might not be an issue, since the natural
                    order of tokens is along their occurence in primary text. In a Salt model all
                    tokens are contained in a single list, which is sorted by the insertion of the
                    tokens. Imagine a primary text "<emphasis role="italic">This is a
                        sample</emphasis>" tokenized in 4 tokens. If token <emphasis role="italic"
                            >t<subscript>3</subscript></emphasis> ("a") was inserted into the list
                    before token <emphasis role="italic">t<subscript>2</subscript></emphasis> ("is")
                    was inserted, the order of the list would be <emphasis role="italic"
                            >t<subscript>1</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>3</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>2</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>4</subscript></emphasis>. Salt provides methods to reorder
                    this list along the offset in primary text
                        (<classname>STextualRelatuin.sLeft</classname>). But what is with multiple
                    texts? If we have multiple texts and order the corresponding tokens by their
                    textual offset, we will end up with a mixed list of tokens of both texts.
                    Imagine a second text "What a nice sample" also tokenized into 4 tokens
                        <emphasis role="italic">t<subscript>21</subscript></emphasis>, <emphasis
                        role="italic">t<subscript>22</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>23</subscript></emphasis> and <emphasis role="italic"
                            >t<subscript>24</subscript></emphasis>. The token list ordered by the
                    textual offset would be the following useless list: <emphasis role="italic"
                            >t<subscript>1</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>21</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>2</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>22</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>23</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>3</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>4</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>24</subscript></emphasis>. A second option is the ordering
                    by the offset in the timeline. Imagine both primary texts as a dialogue between
                    two persons, with the following temporal order. <table frame="all"
                        xml:id="table_dialogue">
                        <title>Both texts as a dialogue.</title>
                        <tgroup align="left" cols="10" colsep="1" rowsep="1">
                            <colspec colname="c1" colnum="1"/>
                            <colspec colname="c2" colnum="2"/>
                            <colspec colname="c3" colnum="3"/>
                            <colspec colname="c4" colnum="4"/>
                            <colspec colname="c5" colnum="5"/>
                            <colspec colname="c6" colnum="6"/>
                            <colspec colname="c7" colnum="7"/>
                            <colspec colname="c8" colnum="8"/>
                            <tbody>
                                <row>
                                    <entry>spk1:</entry>
                                    <entry>This</entry>
                                    <entry>is</entry>
                                    <entry>a</entry>
                                    <entry>sample</entry>
                                    <entry namest="c7" nameend="c8"/>
                                </row>
                                <row>
                                    <entry>spk2: </entry>
                                    <entry namest="c2" nameend="c3"/>
                                    <entry>What</entry>
                                    <entry>a</entry>
                                    <entry>nice</entry>
                                    <entry>sample</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>This will result in a list of the order: <emphasis role="italic"
                            >t<subscript>1</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>2</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>3</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>21</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>4</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>22</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>23</subscript></emphasis>, <emphasis role="italic"
                            >t<subscript>24</subscript></emphasis>. This list now represents the
                    temporal order, but the tokens are also mixed in sense of the correspondance to
                    the primary texts.</para>
                <itemizedlist>
                    <listitem>
                        <para>ordering can be understood and realized in several ways or dimensions.
                            What in one case can be a good order, can be very wrong in another case.
                            To respect this, Salt provides different meanings of order. In the
                            following we will go step by step, throuh their different levels.</para>
                    </listitem>
                    <listitem>
                        <para>general order via list behaviour, where is the problem -> list is
                            sorted by order of inserts :-( can be rearanged</para>
                    </listitem>
                    <listitem>
                        <para>order is implicit by order in text -> what is with parallel data ->
                            order by timeline</para>
                    </listitem>
                    <listitem>
                        <para>what is with tokens at same time, or for instance subtokenization (see
                            segmentation)</para>
                    </listitem>
                    <listitem>
                        <para>therefore we have SOrderRelation</para>
                    </listitem>
                </itemizedlist>
            </sect3>
            <sect3 xml:id="sec_audioData">
                <title>Audio data</title>
                <para>Next to textual born data like news paper articles, essays, internet chats
                    etc. linguistics is also interested in spoken data like dialogues etc. . Even if
                    Salt is a text based model for linguistic data, it can also deal with audio data
                    in two different ways. That means, that audio data can be annotations or primary
                    data. To create an audio annotation, the
                        <classname>SAnnotation.sValue</classname> must be set to an URI pointing to
                    the audio file. To use audio data as primary data, Salt contains the model
                    elements <classname>SAudioDataSource</classname> and
                        <classname>SAudioDSRelation</classname>. These elements are very similar to
                    the elements <classname>STextualDS</classname> and
                        <classname>STextualRelation</classname>. The element
                        <classname>SAudioDataSource</classname> is also derived from the element
                        <classname>SSequentialDS</classname>, it provides the field
                        <classname>sAudioReference</classname> wich contains a URI referring to an
                    audio file. With an object of type <classname>SAudioDSRelation</classname>, we
                    now can connect such audio data with a token. To address a range in the entire
                    audio stream, the element <classname>SAudioDSRelation</classname> contains the
                    fields <classname>sStart</classname> and <classname>sEnd</classname> to address
                    the beginning and the end of that range. <xref linkend="fig_sAudioData"/> shows
                    the named elements in Salt and their relation to each other. <figure
                        xml:id="fig_sAudioData">
                        <title>audio data in Salt</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata width="150" fileref="images/sAudioData.png"/>
                            </imageobject>
                        </mediaobject>
                    </figure></para>
                <para> As already mentioned, Salt was created to handle textual data in the first
                    place, it is usual to also have a transcription of these audio data in Salt. To
                    connect tokens to a primary text next to an audio source is quite simple. You
                    just need to create <classname>STextualRelation</classname> objects and let them
                    point to the <classname>STextualDS</classname> object containing the primary
                    text. Imagine the primary text "Is this example more complicated than it appears
                    to be?", which is tokenized by words and a corresponding audio file. <xref
                        linkend="fig_audioSample"/> shows the relation of a token <emphasis
                        role="italic">tok1</emphasis> (just as a sample), the primary text <emphasis
                        role="italic">text1</emphasis>, the audio date <emphasis role="italic"
                        >audio1</emphasis> via the <classname>STextualRelation</classname> object
                        <emphasis role="italic">sTextRel</emphasis> and the
                        <classname>SAudioDSRelation</classname>
                    <emphasis role="italic">sAudioRel</emphasis>.<figure xml:id="fig_audioSample">
                        <title>A sample of audio data in combination with primary text</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata width="150" fileref="images/audioSample.png"/>
                            </imageobject>
                        </mediaobject>
                    </figure></para>
                <para>In Salt, the number of <classname>SAudioDataSource</classname> objects a model
                    can have is not restricted and you can add as many of them as you like. You can
                    also combine the use of multiple audio and textual primary data with the use of
                    a common timeline. The use of the timeline allows you to model the temporal
                    order of tokens in such a case. Imagine a dialogue consisting of two speakers,
                    an audio recording for each speaker <emphasis role="italic">audio1</emphasis>
                    and <emphasis role="italic">audio2</emphasis> and a corresponding transcription
                    to each audio recording <emphasis role="italic">text1</emphasis> and <emphasis
                        role="italic">text2</emphasis>.  Since in an ordenary dialogue, the speakers
                    are somtimes talking disordered or in parallel, the temporal order cannot be
                    represented by the order of the tokens. To do so, you just need to add an object
                    of type <classname>STimeRelation</classname> and connect each token with the
                    time line, for more information see <xref linkend="sec_time"/>.</para>
            </sect3>
            <sect3 xml:id="sec_id">
                <title>Identifying an object via SName, SId and SElementId</title>
                <para/>
            </sect3>
        </sect2>
    </sect1>
    <sect1 xml:id="sec_insides">
        <title>Insides of Salt</title>
        <para>In fact, the Salt model is not just a monolithic model, it consists of three single
            models which are derived from each other. </para>
        <sect2 xml:id="sec_sfeature">
            <title>Sfeature</title>
            <para> An <classname>SFeature</classname>, but still we want to explain it here. An
                    <classname>SFeature</classname> in Salt is used to add model attributes as
                labels to nodes, edges etc. . In Salt, even primary texts (which are the base for
                linguistic work) are modeled as nodes. Since nodes are just placeholders, such texts
                have to be represented as the value of labels. Such a label is neither a linguistic
                annotation nor a meta annotation and not even a processing annotation. This makes it
                necessary to introduce another type of labels. In the following, we will show some
                features used in Salt, for instance <xref linkend="sec_primData"/> describes in more
                detail how primary texts are represented in Salt by using an
                    <classname>SFeature</classname>.</para>
        </sect2>
    </sect1>
</article>
